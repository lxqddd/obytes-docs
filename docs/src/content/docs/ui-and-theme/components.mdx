---
title: UI 组件
description: 所有 UI 组件的列表及其使用方法。
head:
  - tag: title
    content: UI 组件 | React Native / Expo Starter
---

import { FileTree } from '@astrojs/starlight/components';
import CodeBlock from '../../../components/code.astro';

该启动模板提供了一套基础组件和基于 Nativewind 的简单设计系统，帮助您快速入门并节省时间。

所有这些组件都可以在 `src/components/ui` 文件夹中找到。我们的理念是保持组件尽可能简单，避免添加过多逻辑。这样，它们更容易被重用和自定义。

根据您的需求，您可以直接使用这些组件，也可以对其进行自定义修改。您还可以基于相同的方法创建新的组件。

<FileTree>

- ui ## core ui and theme configuration
  - button.tsx
  - checkbox.tsx
  - colors.js
  - focus-aware-status-bar.tsx
  - icons/
  - image.tsx
  - index.tsx
  - input.tsx
  - list.tsx
  - modal.tsx
  - progress-bar.tsx
  - select.tsx
  - text.tsx
  - utils.tsx

</FileTree>

:::tip
为了在创建新组件或屏幕时节省时间，我们可以简单地输入 `comp` 然后按 Enter 键来生成具有正确结构的新组件。

![Create component](https://github.com/obytes/react-native-template-obytes/assets/11137944/ca84555f-12b7-4048-98b8-3c8391bd9918)
:::

## List

`List` 组件引用了 `@shopify/flash-list` 包中的 FlashList 组件。

<CodeBlock file="src/components/ui/list.tsx" />

**Props**

- 支持所有 `@shopify/flash-list` 的 Props

我们还提供了一个 `EmptyList` 组件，您可以在列表为空时使用它来显示消息。请根据您的需求自由自定义它。

**Use Case**

```tsx
import * as React from 'react';
import { List, EmptyList, Text } from '@/components/ui';

const MyComponent = () => {
  return (
    <List
      data={['Item 1', 'Item 2']}
      renderItem={({ item }) => <Text>{item}</Text>}
      ListEmptyComponent={<EmptyList message="No items" />}
    />
  );
};
```

## Image

对于 `Image` 组件，我们使用 `expo-image` 库来提供快速且高性能的图像组件。`Image` 组件是 `expo-image` 包中 `Image` 组件的包装器，并通过 `nativewind` 提供额外的样式。
`nativewind` 的 `cssInterop` 函数用于应用样式，这样 `className` 属性就会应用到 `Image` 组件的 `style` 属性上。

<CodeBlock file="src/components/ui/image.tsx" />

**Props**

- 支持所有 `expo-image` 的 Props
- `className` - Tailwind CSS 类名

**Use Case**

```tsx
import * as React from 'react';
import { Image } from '@/components/ui';

const MyComponent = () => {
  return (
    <Image
      className="w-32 h-32"
      source={{
        uri: 'https://images.unsplash.com/photo-1524758631624-e2822e304c36',
      }}
    />
  );
};
```

## Text

使用这个自定义的 Text 组件，您可以将翻译键作为 `tx` 属性，它会根据当前语言环境自动翻译文本，同时支持基于所选语言环境的自右向左 (RTL) 语言。

<CodeBlock file="src/components/ui/text.tsx" />

:::tip
您还可以使用 `t` 代码片段来创建一个具有默认 `className` 的简单 Text。
:::

**Props**

- 支持所有 React Native Text Props
- `className` - Tailwind CSS 类名
- `tx` - 翻译键

**Use Case**

```tsx
import * as React from 'react';
import { Text, View } from 'react-native';

const MyComponent = () => {
  return (
    <View className="flex flex-col items-center justify-center">
      <Text className="text-2xl" tx="welcome" />
      <Text className="text-md" className="text-base">
        Hello world
      </Text>
    </View>
  );
};
```

## Button

该启动模板提供了一个简单的 `Button` 组件，您可以使用它通过 Tailwind CSS 类和变体定义来创建一个基本的 `Pressable` 组件配合 `Text`。这些变体的逻辑基于 `tailwind-variants` 包。

`tailwind-variants` 的 `tv` 函数用于创建一个函数，该函数基于插槽定义、变体、大小、禁用状态、全宽度和默认变体来生成 Button 组件的样式配置对象。因此，`styles` 使用 `button` 函数根据提供的 props 来定义 Button 的样式。

每个变体都应包含 `container`、`indicator` 和 `label` 键的样式。`container` 样式用于 `Pressable`，`label` 样式用于 `Text` 组件，`indicator` 样式用于当 `loading` 属性为 `true` 时的 `ActivityIndicator` 组件。

<CodeBlock file="src/components/ui/button.tsx" />

**Props**

- 支持所有 React Native Pressable Props。
- `variant` - Button 变体，`variant` 对象键之一（默认：`default`）
- `loading` - 显示加载指示器（默认：`false`）
- `label` - Button 标签
- `size` - Button 大小，变体 `size` 对象键之一（默认：`default`）
- `className` - 要应用到 Button 容器的 Tailwind CSS 类名
- `textClassName` - Button 标签的额外样式

**Use Case**

<CodeBlock file="src/components/buttons.tsx" />

## Input

我们提供了一个简单的 `Input` 组件，其中包含用于标签的 `Text` 组件和用于输入的 `TextInput` 组件。

您可以像使用 React Native 的 `TextInput` 组件一样使用它，但具有额外的 props 来自定义标签和错误样式。

该组件使用 Tailwind Variants 的 tv 函数来定义样式插槽和变体，用于不同的状态，如聚焦、错误和禁用。这些样式会根据组件的状态和 props 动态应用。

我们尽量保持 `Input` 组件尽可能简单，但您可以添加更多功能，例如 `onFocus` 和 `onBlur`，或者为输入框添加左右图标。

<CodeBlock file="src/components/ui/input.tsx" />

**Props**

- 支持所有 React Native TextInput Props
- `label` - Input 标签
- `error` - Input 错误消息

我们还提供了一个简单的 `ControlledInput` 组件，它在底层使用 `Input` 组件，但通过 `react-hook-form` 的 `useController` 钩子使其可以与 `react-hook-form` 库一起使用。

了解更多关于表单处理的信息 [请点击此处](../forms/)。

**Use Case**

```tsx
import * as React from 'react';
import { Input, View } from '@/components/ui';

const MyComponent = () => {
  return (
    <View className="flex flex-col items-center justify-center">
      <Input label="Email" error="Email is required" />
    </View>
  );
};
```

## Modal

我们提供了一个简单的 `Modal` 组件，使用 `@gorhom/bottom-sheet` 库在屏幕底部显示模态框。

我们选择使用底部工作表而不是模态框，以使其更加灵活和易于使用，同时对逻辑和 UI 具有完全控制权。

根据您的需求，如果模态框内容没有固定高度，您可以使用 `Modal`。

<CodeBlock file="src/components/ui/modal.tsx" />

**Props**

- 支持所有 `@gorhom/bottom-sheet` 的 Props
- `children` - Modal 内容
- `title`: `string` - Modal 标题

**Use Case**

```tsx
import * as React from 'react';
import { Modal, useModal, View, Button, Text } from '@/components/ui';

const MyComponent = () => {
  const modal = useModal();

  return (
    <View className="flex flex-col items-center justify-center">
      <Button variant="primary" label="Show Modal" onPress={modal.present} />
      <Modal ref={modal.ref} title="modal title" snapPoints={['60%']}>
        <Text>Modal Content</Text>
      </Modal>
    </View>
  );
};
```

## Select

我们提供了一个简单的 `Select` 组件，使用底部工作表配合简单的 List 组件来从项目列表中选择一个项目。

我们选择使用底部工作表而不是下拉菜单，以使其在 iOS 和 Android 上都更加灵活和易于使用，同时最大限度地减少启动模板中的依赖项数量。

该组件使用 Tailwind Variants 的 `tv` 函数来定义样式插槽和变体，用于不同的状态，如错误和禁用。这些样式会根据组件的状态和 props 动态应用。

请根据您的需求自由更新组件实现，只要保持 `Select` 组件的相同 Props 签名，该组件就会与我们的表单处理解决方案无缝配合，无需任何更改。

<CodeBlock file="src/components/ui/select.tsx" />

**Props**

- `label`: `string` - Input 标签
- `error`: `string` - Input 错误消息
- `options` : `{ label: string; value: string | number }` 数组 - 要从中选择的项列表
- `value` : `string | number` - 选定的项值
- `onSelect`: `(option: Option) => void;` - 处理项选择的回调函数
- `placeholder`: `string`- 占位符文本
- `disabled`: `boolean` - 禁用选择输入（默认：`false`）

**Use Case**

```tsx
import * as React from 'react';

import type { Option } from '@/components/ui';
import { SelectInput, View } from '@/components/ui';

const options: Option[] = [
  { value: 'chocolate', label: 'Chocolate' },
  { value: 'strawberry', label: 'Strawberry' },
  { value: 'vanilla', label: 'Vanilla' },
];

const MyComponent = () => {
  const [value, setValue] = React.useState<string | number | undefined>();
  return (
    <View className="flex flex-col items-center justify-center">
      <Select
        label="Select"
        error="Select is required"
        options={options}
        value={value}
        onSelect={(option) => setValue(option.value)}
      />
    </View>
  );
};
```

## Controlled Select

我们提供了一个简单的 `ControlledSelect` 组件，它在底层使用 `Select` 组件，但通过 `react-hook-form` 的 `useController` 钩子使其可以与 `react-hook-form` 库一起使用。

了解更多关于表单处理的信息 [请点击此处](../forms/)。

## Checkbox, Radio & Switch

我们提供了一套三个简单且可自定义的组件，包括 `Checkbox`、`Radio` 和 `Switch`，它们在底层共享相同的逻辑。

`Checkbox`、`Switch` 和 `Radio` 组件非常相似，因为它们共享一个通用结构并且应该处理布尔值，它们的主要区别在于显示的图标和相关的辅助标签。每个组件都接受一系列 props，允许我们自定义它们的外观、行为和辅助功能特性。

为了处理常见功能，如处理按压事件和辅助状态，我们有 `Root` 组件。它将子组件包装在 `Pressable` 组件中并传递 props。

动画使用 `moti` 库的 `MotiView` 组件应用到图标上。这些动画会根据选中状态改变图标的外观。

<CodeBlock file="src/components/ui/checkbox.tsx" />

**Props**

- 支持所有 React Native Pressable Props（不包括 `onPress` 属性）
- `onChange` - (checked: boolean) => void;` - 处理组件状态的回调函数
- `checked` - `boolean`- 确定组件的状态（默认：`false`）
- `label` - 组件的标签
- `accessibilityLabel` - 组件的辅助标签
- `children` - 子组件/元素
- `className` - Tailwind CSS 类名
- `disabled`: `boolean` - 禁用组件（默认：`false`）

**Use Case**

```tsx
import { Checkbox } from '@/components/ui';

const App = () => {
  const [checked, setChecked] = useState(false);

  return (
    <Checkbox
      checked={checked}
      onChange={setChecked}
      accessibilityLabel="accept terms of condition"
      label="I accept terms and conditions"
    />
  );
};
```

默认情况下，组件会渲染一个带有您作为 label 属性传递的文本的标签，点击标签也会切换组件。

要渲染自定义的 Checkbox，您可以使用 `Checkbox.Root`、`Checkbox.Icon` 和 `Checkbox.Label` 组件。

```tsx
import { Checkbox } from '@/components/ui';

const App = () => {
  const [checked, setChecked] = useState(false);

  return (
    <Checkbox.Root
      checked={checked}
      onChange={setChecked}
      accessibilityLabel="accept terms of condition"
    >
      <Checkbox.Icon checked={checked} />
      <Checkbox.Label text="I agree to terms and conditions" />
    </Checkbox.Root>
  );
};
```
